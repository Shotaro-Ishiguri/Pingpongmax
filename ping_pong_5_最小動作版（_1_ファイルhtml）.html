<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>PingPong Split — 100pts</title>
  <style>
    html, body { height:100%; margin:0; background:#0d1117; color:#e6edf3; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Noto Sans, sans-serif; }
    #game { display:block; width:100vw; height:100vh; }
    #hud { position:fixed; inset:12px auto auto 12px; background:rgba(0,0,0,.35); padding:8px 10px; border-radius:10px; font-size:12px; backdrop-filter: blur(6px); }
  </style>
</head>
<body>
<canvas id="game"></canvas>
<div id="hud">W/S と ↑/↓ で操作。P で一時停止、R でリスタート。Enter で開始／続行。<br>仕様：パドル命中で球が分裂、壁で少し加速。100点先取。点が入っても試合は止まらない。</div>
<script>
(() => {
  const cvs = document.getElementById('game');
  const ctx = cvs.getContext('2d');
  const state = {
    w: 0, h: 0, dpr: 1,
    scene: 'title',
    last: performance.now(),
    keys: new Set(),
    score: { p1: 0, p2: 0 },
    paused: false,
  };

  // 設定
  const PADDLE_SPEEDUP = 1.2;
  const WALL_SPEEDUP   = 1.02;
  const MAX_BALL_SPEED = 1200;
  const MAX_BALLS      = 64;
  const WIN_SCORE      = 100; // 100点先取

  function resize(){
    const dpr = Math.min(2, window.devicePixelRatio || 1);
    state.dpr = dpr;
    state.w = Math.floor(window.innerWidth * dpr);
    state.h = Math.floor(window.innerHeight * dpr);
    cvs.width = state.w; cvs.height = state.h;
    cvs.style.width = '100vw'; cvs.style.height = '100vh';
    ctx.setTransform(1,0,0,1,0,0);
    ctx.scale(dpr, dpr);
  }
  addEventListener('resize', resize); resize();

  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const rand = (a,b)=>a+Math.random()*(b-a);

  const pad = (isLeft) => ({
    x: isLeft ? 48 : window.innerWidth - 48 - 12,
    y: window.innerHeight/2 - 80,
    w: 12, h: 160,
    speed: 420,
    isCPU: !isLeft,
    vy: 0,
  });
  let p1 = pad(true), p2 = pad(false);

  const ball0 = () => ({ x: window.innerWidth/2, y: window.innerHeight/2, r: 9, vx: 0, vy: 0, speed: 380 });
  let balls = [ ball0() ];

  const keymap = { ArrowUp:'up', ArrowDown:'down', KeyW:'w', KeyS:'s', KeyP:'pause', KeyR:'restart', Enter:'enter' };
  addEventListener('keydown', e => {
    const k = keymap[e.code]; if(!k) return;
    if(k==='pause'){ state.paused = !state.paused; e.preventDefault(); return; }
    if(k==='restart'){ resetMatch(); e.preventDefault(); return; }
    state.keys.add(k); e.preventDefault();
  }, { passive:false });
  addEventListener('keyup', e => { const k = keymap[e.code]; if(!k) return; state.keys.delete(k); });

  function serveBall(b, toward){
    b.x = window.innerWidth/2; b.y = window.innerHeight/2;
    const dir = toward==='right' ? 1 : -1;
    const angle = rand(-0.25, 0.25);
    const sp = b.speed;
    b.vx = Math.cos(angle)*sp*dir;
    b.vy = Math.sin(angle)*sp;
  }

  function startIfNeeded(){
    if(state.scene==='title' && state.keys.has('enter')){
      state.scene='play';
      serveBall(balls[0], 'right');
    } else if(state.scene==='gameover' && state.keys.has('enter')){
      resetMatch();
    }
  }

  function resetMatch(){
    state.scene='play'; state.score.p1=0; state.score.p2=0;
    p1=pad(true); p2=pad(false); balls=[ball0()];
    state.paused=false; serveBall(balls[0],'right');
  }

  // CPU難易度を1.2倍
  const ai = { maxFollow: 360*1.2, lead: 0.18, mistakeChance: 0.02, mistakeTimer: 0 };
  function updateAI(dt){
    if(!p2.isCPU) return;
    if(ai.mistakeTimer>0) ai.mistakeTimer -= dt; else if(Math.random()<ai.mistakeChance*dt) ai.mistakeTimer = rand(0.15,0.35);
    let targetBall = balls[0];
    for(const b of balls){ if(!targetBall || b.x > targetBall.x) targetBall = b; }
    let target = targetBall ? (targetBall.y + targetBall.vy*ai.lead) : window.innerHeight/2;
    if(ai.mistakeTimer>0) target += (Math.random()<0.5?-1:1)*60;
    const center = p2.y + p2.h/2;
    const dy = target - center; const dir = Math.sign(dy);
    p2.vy = dir * ai.maxFollow; if(Math.abs(dy)<24) p2.vy *= 0.4;
    p2.y += p2.vy*dt; p2.y = clamp(p2.y,0,window.innerHeight-p2.h);
  }

  function rectCircleCollide(px,py,pw,ph, cx,cy,cr){
    const nx = clamp(cx, px, px+pw), ny = clamp(cy, py, py+ph);
    const dx = cx - nx, dy = cy - ny; return dx*dx + dy*dy <= cr*cr;
  }
  function limit(vx,vy){
    const s = Math.hypot(vx,vy); if(s<=MAX_BALL_SPEED) return {vx,vy};
    const k = MAX_BALL_SPEED/s; return {vx:vx*k, vy:vy*k};
  }

  function splitBounce(ball, paddle){
    const pc = paddle.y + paddle.h/2;
    const hit = clamp((ball.y - pc)/(paddle.h/2), -1, 1);
    const maxA = Math.PI/3;
    const baseAng = hit*maxA; const dir = (paddle===p1)?1:-1;
    const baseSpeed = Math.min(Math.hypot(ball.vx,ball.vy)*PADDLE_SPEEDUP, MAX_BALL_SPEED);
    const delta = 0.18;
    const angs = [baseAng-delta, baseAng+delta];
    const out = [];
    for(const ang of angs){
      const v = limit(Math.cos(ang)*baseSpeed*dir, Math.sin(ang)*baseSpeed);
      out.push({x:dir>0?paddle.x+paddle.w+ball.r+1:paddle.x-ball.r-1,y:ball.y,r:ball.r,vx:v.vx,vy:v.vy,speed:ball.speed});
    }
    return out;
  }

  function updateBalls(dt){
    const next = [];
    for(const b of balls){
      const br = b.r; let segs = [{x:b.x,y:b.y,vx:b.vx,vy:b.vy}]; let scored=null;
      const steps = Math.max(1, Math.ceil((Math.abs(b.vx)+Math.abs(b.vy))*dt/600));
      const sub = dt/steps;
      for(let s=0;s<steps;s++){
        const stage=[];
        for(const sg of segs){
          let x=sg.x+sg.vx*sub, y=sg.y+sg.vy*sub, vx=sg.vx, vy=sg.vy;
          if(y-br<0){ y=br; vy=-vy*WALL_SPEEDUP; }
          if(y+br>window.innerHeight){ y=window.innerHeight-br; vy=-vy*WALL_SPEEDUP; }
          let split=false;
          if(vx<0 && rectCircleCollide(p1.x,p1.y,p1.w,p1.h,x,y,br)){
            const spawned = balls.length<MAX_BALLS? splitBounce({x,y,r:br,vx,vy,speed:b.speed},p1):[];
            for(const nb of spawned) stage.push({x:nb.x,y:nb.y,vx:nb.vx,vy:nb.vy}); split=true;
          }
          if(vx>0 && rectCircleCollide(p2.x,p2.y,p2.w,p2.h,x,y,br)){
            const spawned = balls.length<MAX_BALLS? splitBounce({x,y,r:br,vx,vy,speed:b.speed},p2):[];
            for(const nb of spawned) stage.push({x:nb.x,y:nb.y,vx:nb.vx,vy:nb.vy}); split=true;
          }
          if(split) continue;
          if(x+br<0){ scored='p2'; continue; }
          if(x-br>window.innerWidth){ scored='p1'; continue; }
          stage.push({x,y,vx,vy});
        }
        segs=stage; if(scored) break;
      }
      if(scored){
        state.score[scored]++;
        const nb=ball0(); serveBall(nb,scored==='p1'?'right':'left'); next.push(nb);
      } else {
        for(const sg of segs){ const v=limit(sg.vx,sg.vy); next.push({x:sg.x,y:sg.y,r:br,vx:v.vx,vy:v.vy,speed:b.speed}); if(next.length>=MAX_BALLS) break; }
      }
      if(next.length>=MAX_BALLS) break;
    }
    balls=next.length?next:[ball0()];
  }

  function update(dt){
    if(state.scene!=='play'||state.paused) return;
    let v1=0,v2=0; if(state.keys.has('w')) v1-=1; if(state.keys.has('s')) v1+=1;
    if(!p2.isCPU){ if(state.keys.has('up')) v2-=1; if(state.keys.has('down')) v2+=1; }
    p1.y += v1*p1.speed*dt; p1.y=clamp(p1.y,0,window.innerHeight-p1.h);
    if(!p2.isCPU){ p2.y += v2*p2.speed*dt; p2.y=clamp(p2.y,0,window.innerHeight-p2.h); }
    updateAI(dt);
    updateBalls(dt);
    if(state.score.p1>=WIN_SCORE||state.score.p2>=WIN_SCORE) state.scene='gameover';
  }

  function draw(){
    ctx.clearRect(0,0,cvs.width,state.h);
    const g=ctx.createLinearGradient(0,0,0,window.innerHeight); g.addColorStop(0,'#111827'); g.addColorStop(1,'#0d1117');
    ctx.fillStyle=g; ctx.fillRect(0,0,window.innerWidth,window.innerHeight);
    ctx.strokeStyle='#22314a'; ctx.lineWidth=4; ctx.setLineDash([12,12]); ctx.beginPath(); ctx.moveTo(window.innerWidth/2,0); ctx.lineTo(window.innerWidth/2,window.innerHeight); ctx.stroke(); ctx.setLineDash([]);
    ctx.fillStyle='#cbd5e1'; ctx.fillRect(p1.x,p1.y,p1.w,p1.h); ctx.fillRect(p2.x,p2.y,p2.w,p2.h);
    ctx.beginPath(); for(const b of balls){ ctx.moveTo(b.x+b.r,b.y); ctx.arc(b.x,b.y,b.r,0,Math.PI*2); } ctx.fill();
    ctx.fillStyle='#e6edf3'; ctx.font='700 24px ui-sans-serif, system-ui'; ctx.textAlign='center'; ctx.fillText(state.score.p1,window.innerWidth/2-40,40); ctx.fillText(state.score.p2,window.innerWidth/2+40,40);
    if(state.scene!=='play'){
      ctx.fillStyle='#e6edf3'; ctx.textAlign='center';
      if(state.scene==='title'){
        ctx.font='800 40px ui-sans-serif, system-ui'; ctx.fillText('PingPong Split — 100pts',window.innerWidth/2,window.innerHeight/2-20);
        ctx.font='500 16px ui-sans-serif, system-ui'; ctx.fillText('Enter で開始 / P で一時停止 / R でリスタート',window.innerWidth/2,window.innerHeight/2+16);
      } else if(state.scene==='gameover'){
        const win = state.score.p1>=WIN_SCORE?'You Win':'You Lose';
        ctx.font='800 40px ui-sans-serif, system-ui'; ctx.fillText(win,window.innerWidth/2,window.innerHeight/2-20);
        ctx.font='500 16px ui-sans-serif, system-ui'; ctx.fillText('Enter で再戦 / R でスコアリセット',window.innerWidth/2,window.innerHeight/2+16);
      }
    }
    if(state.paused&&state.scene==='play'){
      ctx.fillStyle='rgba(0,0,0,.45)'; ctx.fillRect(0,0,window.innerWidth,window.innerHeight);
      ctx.fillStyle='#e6edf3'; ctx.textAlign='center'; ctx.font='800 36px ui-sans-serif, system-ui'; ctx.fillText('PAUSED',window.innerWidth/2,window.innerHeight/2);
    }
  }

  function loop(now){
    const dt=Math.min(0.033,(now-state.last)/1000); state.last=now; startIfNeeded(); if(!state.paused) update(dt); draw(); requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
